#include <3ds.h>
#include <citro3d.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "lodepng.h"
#include "types.h"
#include "scene_context.h"
#include "drawing.h"

// These headers are generated by the build process
#include "ballsprites_png.h"
#include "masterball_png.h"
#include "vshader_shbin.h"

static void moveSprite(Sprite* sprites);
static void printDebugInfo();
static void loadPngForGpu(SceneContext *scene);
static SceneContext* sceneInit();

int main(int argc, char **argv) {
	// Initialize graphics
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);
	consoleInit(GFX_BOTTOM, NULL);

	// Initialize the render target
	C3D_RenderTarget* target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8,
                                                      GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	// Initialize the scene
	SceneContext *scene = sceneInit();

    // create sprites
    Sprite *sprite = new Sprite();
    sprite->imageDimension = {0.0f, 1.0f, 0.0f, 1.0f};
    sprite->width = sprite->height = 32;

    srand(time(NULL));

	// random place and speed
	sprite->x = rand() % (SCREEN_WIDTH - 148);
	sprite->y = rand() % (SCREEN_HEIGHT - 148);
	sprite->dx = rand()*4.0f/RAND_MAX - 2.0f;
	sprite->dy = rand()*4.0f/RAND_MAX - 2.0f;

	// Main loop
	while (aptMainLoop()) {

		hidScanInput();

		// Respond to user input
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) {
			break; // break in order to return to hbmenu
        }

		moveSprite(sprite);
        printDebugInfo();

		// Render the scene
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			drawSprite(scene, sprite);
		C3D_FrameEnd(0);
	}

	// Deinitialize the scene
	delete scene;

	// Deinitialize graphics
	C3D_Fini();
	gfxExit();
	return 0;
}

static void moveSprite(Sprite* sprite)
{
	sprite->x += sprite->dx;
	sprite->y += sprite->dy;

	// check for collision with the screen boundaries
	if (sprite->x < 1 || sprite->x > (400 - 32)) {
		sprite->dx = -sprite->dx;
    }

	if (sprite->y < 1 || sprite->y > (240 - 32)) {
		sprite->dy = -sprite->dy;
    }
}

static void printDebugInfo()
{
    printf("\x1b[3;1HCPU:     %6.2f%%\x1b[K", C3D_GetProcessingTime() * 6.0f);
    printf("\x1b[4;1HGPU:     %6.2f%%\x1b[K", C3D_GetDrawingTime() * 6.0f);
    printf("\x1b[5;1HCmdBuf:  %6.2f%%\x1b[K", C3D_GetCmdBufUsage() * 100.0f);
}

static void loadPngForGpu(SceneContext *scene)
{
    unsigned char* image;
    unsigned width, height;

    lodepng_decode32(&image, &width, &height, masterball_png, masterball_png_size);
    printf("\x1b[7;1HWidth: %zu, Height: %zu\x1b[K", width, height);

    u8 *gpusrc = (u8*) linearAlloc(width * height * 4);
    shiftEndianess(image, gpusrc, width, height);

    // ensure data is in physical ram
    GSPGPU_FlushDataCache(gpusrc, width * height * 4);

    // Load the texture and bind it to the first texture unit
    C3D_TexInit(&scene->spritesheet_tex, width, height, GPU_RGBA8);

    // Convert image to 3DS tiled texture format
    u32 buffDimension = GX_BUFFER_DIM(width, height);
    C3D_SafeDisplayTransfer((u32*) gpusrc, buffDimension,
                            (u32*) scene->spritesheet_tex.data,
                            buffDimension, TEXTURE_TRANSFER_FLAGS);
    gspWaitForPPF();

    C3D_TexSetFilter(&scene->spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
    C3D_TexBind(0, &scene->spritesheet_tex);

    free(image);
    linearFree(gpusrc);
}

static SceneContext* sceneInit()
{
	SceneContext* scene = new SceneContext();
	scene->InitShader();

	// Allocate VBO
    scene->vbo = (VBOEntry*) linearAlloc(sizeof(VBOEntry) * 6);

    // Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);
	BufInfo_Add(bufInfo, scene->vbo, sizeof(VBOEntry), 2, 0x10);

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&scene->projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);

    loadPngForGpu(scene);

	// Configure depth test to overwrite pixels with the same depth
    // (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);

	return scene;
}
