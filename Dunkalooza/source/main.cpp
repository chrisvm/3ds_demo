#include <3ds.h>
#include <citro3d.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "lodepng.h"
#include "types.h"
#include "scene_context.h"
#include "drawing.h"

// These headers are generated by the build process
#include "spaceship_png.h"
#include "vshader_shbin.h"

static void moveSprite(Sprite* sprites, u32 kDown);
static void printDebugInfo();
static void loadPngForGpu(SceneContext *scene);
static SceneContext* sceneInit();

int main(int argc, char **argv) {
	// Initialize graphics
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);
	consoleInit(GFX_BOTTOM, NULL);

	// Initialize the render target
	C3D_RenderTarget* target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8,
                                                      GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	// Initialize the scene
	SceneContext *scene = sceneInit();

    // create sprites
    Sprite *sprite = new Sprite();
    sprite->imageDimension = {0.0f, 1.0f, 0.0f, 1.0f};
    sprite->width = sprite->height = 32;
	sprite->ang_vel = 0.04;

	// random place and speed
	sprite->x = SCREEN_WIDTH / 2 - (sprite->width / 2);
	sprite->y = SCREEN_HEIGHT / 2 - (sprite->height / 2);
	sprite->dx = sprite->dy = 0;

	// Main loop
	while (aptMainLoop()) {

		hidScanInput();

		// Respond to user input
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) {
			break; // break in order to return to hbmenu
        }

		u32 kHeld = hidKeysHeld();
		moveSprite(sprite, kHeld);
        printDebugInfo();

		// Render the scene
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			drawSprite(scene, sprite);
		C3D_FrameEnd(0);
	}

	// Deinitialize the scene
	delete scene;

	// Deinitialize graphics
	C3D_Fini();
	gfxExit();
	return 0;
}

static void moveSprite(Sprite* sprite, u32 kDown)
{
	sprite->x += sprite->dx;
	sprite->y += sprite->dy;

	if ((kDown & KEY_LEFT) != 0) {
		sprite->rotation -= sprite->ang_vel;
	}

	if ((kDown & KEY_RIGHT) != 0) {
		sprite->rotation += sprite->ang_vel;
	}

	if ((kDown & KEY_UP) != 0) {
		sprite->x += cos(sprite->rotation - M_PI_2) * 5;
		sprite->y += sin(sprite->rotation - M_PI_2) * 5;
	}
}

static void printDebugInfo()
{
    printf("\x1b[3;1HCPU:     %6.2f%%\x1b[K", C3D_GetProcessingTime() * 6.0f);
    printf("\x1b[4;1HGPU:     %6.2f%%\x1b[K", C3D_GetDrawingTime() * 6.0f);
    printf("\x1b[5;1HCmdBuf:  %6.2f%%\x1b[K", C3D_GetCmdBufUsage() * 100.0f);
}

static void loadPngForGpu(SceneContext *scene)
{
    unsigned char* image;
    unsigned width, height;

    lodepng_decode32(&image, &width, &height, spaceship_png, spaceship_png_size);
    printf("\x1b[7;1HWidth: %zu, Height: %zu\x1b[K", width, height);

    u8 *gpusrc = (u8*) linearAlloc(width * height * 4);
    shiftEndianess(image, gpusrc, width, height);

    // ensure data is in physical ram
    GSPGPU_FlushDataCache(gpusrc, width * height * 4);

    // Load the texture and bind it to the first texture unit
    C3D_TexInit(&scene->spritesheet_tex, width, height, GPU_RGBA8);

    // Convert image to 3DS tiled texture format
    u32 buffDimension = GX_BUFFER_DIM(width, height);
    C3D_SafeDisplayTransfer((u32*) gpusrc, buffDimension,
                            (u32*) scene->spritesheet_tex.data,
                            buffDimension, TEXTURE_TRANSFER_FLAGS);
    gspWaitForPPF();

    C3D_TexSetFilter(&scene->spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
    C3D_TexBind(0, &scene->spritesheet_tex);

    free(image);
    linearFree(gpusrc);
}

static SceneContext* sceneInit()
{
	SceneContext* scene = new SceneContext();
	scene->InitShader();

	// Allocate VBO
    scene->vbo = (VBOEntry*) linearAlloc(sizeof(VBOEntry) * 6);

    // Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);
	BufInfo_Add(bufInfo, scene->vbo, sizeof(VBOEntry), 2, 0x10);

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&scene->projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);

    loadPngForGpu(scene);

	return scene;
}
